import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

#lire les données
deaths = pd.read_csv("deaths.csv")
accidents_2017 = pd.read_csv("accidents_2017.csv")
air_quality_Nov2017 = pd.read_csv("air_quality_Nov2017.csv")
air_stations_Nov2017 = pd.read_csv("air_stations_Nov2017.csv")
births = pd.read_csv("births.csv")
bus_stops = pd.read_csv("bus_stops.csv")
immigrants_by_nationality = pd.read_csv("immigrants_by_nationality.csv")
immigrants_emigrants_by_age = pd.read_csv("immigrants_emigrants_by_age.csv")
immigrants_emigrants_by_destination = pd.read_csv("immigrants_emigrants_by_destination.csv")
immigrants_emigrants_by_destination2 = pd.read_csv("immigrants_emigrants_by_destination2.csv")
immigrants_emigrants_by_sex = pd.read_csv("immigrants_emigrants_by_sex.csv")
life_expectancy = pd.read_csv("life_expectancy.csv")
most_frequent_baby_names = pd.read_csv("most_frequent_baby_names.csv")
most_frequent_names = pd.read_csv("most_frequent_names.csv")
population = pd.read_csv("population.csv")
transports = pd.read_csv("transports.csv")
unemployment = pd.read_csv("unemployment.csv")

#choisir quel dataframe sera traité

## prenons population
data = population

print (type(data))


## resumé des statistiques descriptives des colonnes
data.describe(include ='all')

#nous voyons que l'information est affichée pour chaque quartier de 2013 a 2017


#regardons les données
display(data)

#afin de faciliter l'analyse nous filtrerons les données pour garder seulement une année ex :2015
msg = 'choisir une année entre 2013 et 2017\n'
annee = int(input(msg))


#analysons maitenant le df en conservant seulement les données de l'année choisie:

df_tri_année = data[data['Year'] == annee]


display(df_tri_année)
# nous remarquons maitenant que les données semblent sous-divisées par groupe d'age et sexe
# choisons un seul quartier pour analyser avec un peu plus de détail


#mais quels sont les quartiers de Barcelone? demandons a python d'afficher les valeurs uniques des noms de quartiers

colonne = 'Neighborhood.Name'
data[colonne].unique()


#continuons notre analyse en choisisant un quartier maitenant que nous les connaissons ex: 'el Barri Gòtic'

msg = 'choisir un quartier\n'
quartier = []
choix = (input(msg))
quartier.append(choix)
#quartier = 'el Barri Gòtic'


df_tri_quartier = data.loc[data['Neighborhood.Name'].isin(quartier)]
df_tri_quartier

# nous avons reussi a filtrer par quartier mais perdons le filtre par année


# incluons maitenant les deux filtres
df_tri_multiple = data[(data['Year'] == annee) & data['Neighborhood.Name'].isin(quartier)]
df_tri_multiple

#nous remarquons que même après le double tri il y a des lignes preque identiques.
#en fait chaque liste correspond a un citoyen, le colonne nombre correspond a son identifiant!


# regroupons les citoyens par groupe d'age

df_tri_multiple['Age'].value_counts()


## verification des types de données presents dans chaque colonne
data.dtypes


#modifier les types de données si besoin

colonne = 'District.Name'
#print (head(data[colonne]))
data[colonne].head

# Tableau affichant le nombre de population par quartier 

data_nb_population = data.groupby(['Neighborhood.Name'])[['Number']].sum() 


# Tableau affichant le top 10 du nombre de population par quartier
data_nb_population.sort_values(by=["Number"], ascending = False).head(10).round(2) 

# Nous voulons maintenant stocker ce "top 10" dans un dataframe

data_nb_populationtop10 = data_nb_population.sort_values(by=["Number"], ascending = False).head(10).round(2) 
data_nb_populationtop10

# Tableau affichant le top 10 des quartiers avec la plus petite taille de population 

data_nb_populationlast10= data_nb_population.sort_values(by=["Number"], ascending = False).tail(10).round(2) 
data_nb_populationlast10 


------------------------- life_expectancy-------------------------------------------


#On souhaite afficher les 10 quartiers qui ont la meilleure 'life_expectancy' pour le sexe et la période choisis par l'utilisateur.
print(life_expectancy.Gender.unique())
msg = "choisisez le sexe voulu : \n"
choix_s = input(msg)

# afin d'éviter des résultats vides, on vérifie l'input de l'utilisateur avant de continuer.

redemander = 'oui'
while ( redemander == 'oui'):
    if (choix_s == 'Male') or (choix_s == 'Female'):
        print('le sexe choisi est : {0}'.format(choix_s))
        redemander = 'non'
        break
    else : 
        print("Choix inconnu, choissisez entre 'Male' et 'Female' ")
        choix_s = input(msg)
# Afin d'afficher les périodes pour lesquelles les données sont disponibles,
#on stocke les noms des colonnes de la dataframe 'life_expectancy' dans une liste et on garde juste les périodes.
Periode = list(life_expectancy.columns)
del(Periode[0])
del(Periode[-1])
print(Periode)
#choissisez l'index de la periode voulu
msg_p = "choisisez l'index de la periode voulu : 1,2,3,4  \n"
choix_p = input(msg_p)
# puisque les index des listes commencent par 0 et non pas par 1, on change le type de l'input à 'integer' et on diminue le choix de l'utilisateur de '1' . 
choix_p = int(choix_p) -1 
print('la periode choisi est : {0}'.format(Periode[choix_p]))

life_ex = life_expectancy[['Neighborhood','Gender',Periode[choix_p]]]
life_ex = life_ex[(life_ex['Gender'] == choix_s)]
life_ex = life_ex.sort_values(by = Periode[choix_p], ascending = False) 
life_ex

# On remarque qu'il y a des valeurs null qui ont été lues comme 'NaN', 
# donc on souhaite remplacer les 'NaN' dans le resultat par 'No data'.
life_ex[Periode[choix_p]] = life_ex[Periode[choix_p]].fillna("No Data")
life_ex

# Ici on affiche les 5 quartiers qui ont la meilleure 'life_expectancy' selon les criteres choisi : 
life_e = life_ex.head(5)

#affichage
seaborn.catplot(x="Neighborhood", y=Periode[choix_p], kind="bar", data=life_e, aspect=2). \
set(xlabel='Neighborhood', ylabel='life_expectancy', title='life_expectancy selon le quartier')
